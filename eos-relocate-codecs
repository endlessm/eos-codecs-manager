#!/bin/bash -e
# Copyright (C) 2015 Endless Mobile, Inc.
# Licensed under the GPLv2

# Directory where the decrypted codecs will be installed
dest=/var/lib/codecs
mkdir -p ${dest}

exit_with_error() {
    echo "${1}"
    exit 0
}

# Directory where the encrypted codec packs should be installed
source=/usr/share/eos-codecs-manager
if [ ! -d ${source} ]; then
    exit_with_error "No codecs directory at ${source}, exiting"
fi

# Where the GNUPGHOME directory will be for decrypting operations
gnupghome=${dest}/.gnupg

# Drop-in directory where the relevant GPG keys will be picked from
gpgkeysdir=${gnupghome}/keys.d

# REMOVEME: Directory where the private GPG key will be shipped
# to users, TEMPORARILY, along with the 2.5. release only.
keyssourcedir=${source}/.gpgkeys
if [ -d ${keyssourcedir} ]; then
    echo "Pre-distributed GPG keys found, syncing..."
    mkdir -p ${gpgkeysdir}
    rsync -a ${keyssourcedir}/ ${gpgkeysdir}
fi

if [ ! -d ${gnupghome} ]; then
    exit_with_error "No GPG home in ${gnupghome}, exiting"
fi

if [ ! -d ${gpgkeysdir} ]; then
    exit_with_error "No ${gpgkeysdir} directory, exiting"
fi
if [ "x$(ls ${gpgkeysdir})" = "x" ]; then
    exit_with_error "No GPG keys found in ${gpgkeysdir}, exiting"
fi

# We use a small status file to know when we can early return so that
# we don't make the boot process longer than needed, by decrypting
# and uncompressing files just to see if something is copied over.
status_filepath=${dest}/.status
previous_status=$(cat ${status_filepath} 2> /dev/null | sort)

current_status=$(find ${source} -type f -exec md5sum -b '{}' ';' | sort)
if [ "x${current_status}" = "x${previous_status}" ]; then
    echo "No new codecs found. Nothing to do."
    exit 0
fi

# The GNUPGHOME directory needs special permissions
chmod 700 ${gnupghome}

# Import all the valid GPG keys insto the local keyring
for keyfile in ${gnupghome}/keys.d/*; do
    echo "Trying to import GPG key from ${keyfile}..."
    gpg --homedir ${gnupghome} --no-default-keyring --import ${keyfile} || true
done

# Wheter we will need to call ldconfig at the end or not.
needs_update=false

handle_codecpack() {
    local codecs_pack=${1}

    echo "Unpacking files for codec pack '${codecs_pack}'..."

    # Perform all the operations inside a temporary directory
    local tmpdir=$(mktemp -d)
    pushd ${tmpdir}

    # Decrypt the file and extract its contents
    local decrypted_filename=codecs-pack.xz
    gpg --homedir ${gnupghome} \
        --no-default-keyring \
        --output ${decrypted_filename} \
        --verbose \
        ${codecs_pack}

    tar Jxvf ${decrypted_filename}
    rm ${decrypted_filename}

    # Copy files if they are different or not there yet, but ignore
    # timestamp for rsync's 'quick check' algorithm, as time will be
    # always different as we just unpacked the contents right now.
    local changes=$(rsync --recursive \
                          --links \
                          --perms \
                          --group \
                          --owner \
                          --devices \
                          --specials \
                          --itemize-changes \
                          --size-only ./ ${dest})
    # Clean up
    popd
    rm -rf ${tmpdir}

    # Let the caller know when ldconfig will need to be updated
    if [ -n "${changes}" ]; then
        needs_update=true
    fi
}

# Process all the codecs in the source directory, making sure
# that we know when we have updated something in the destination
# directory, so that we don't call ldconfig if not really needed.
for codecs_pack in ${source}/*; do
    handle_codecpack ${codecs_pack}
done

# /var/lib/codecs should be in the search path for ld.so
if ${needs_update}; then
    echo "Codecs changed, running 'ldconfig'..."
    ldconfig -X
    echo "Synchronizing file changes to disk..."
    sync
fi

# Write the status file, so that we won't waste time on next boot
# Note that this line should only be executed if nothing has failed
# yet, otherwise bash -e should already have bailed out by now.
echo "${current_status}" > ${status_filepath}

exit 0
